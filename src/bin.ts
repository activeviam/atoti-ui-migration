import yargs from "yargs";
import fs from "fs-extra";
import path from "path";
import { BehaviorOnError } from "./migration.types";
import { migrateNotebook } from "./migrateNotebook";
import {
  convertFromVersion,
  convertToVersion,
  convertVersions,
  validFromVersions,
  validToVersions,
} from "./convertAtotiToAUIVersions";
import { getTreeColumnWidthFromArgs } from "./getTreeColumnWidthFromArgs";
import { migrateContentServer } from "./migrateContentServer";
import { DataModel, ContentRecord } from "@activeviam/activeui-sdk-5.1";
import { logMigrationReport } from "./logMigrationReport";

const supportedFileExtension = ["JSON", "IPYNB"];

export function getFileExtension(path: string): string {
  const fileExtension = path.split(".").pop()?.toUpperCase();

  if (!fileExtension || !supportedFileExtension.includes(fileExtension)) {
    throw new Error(
      `The extension "${fileExtension}" is not supported. Supported extensions for the input file are "JSON" and "IPYNB"`,
    );
  }
  return fileExtension;
}

yargs
  .command<{
    inputPath: string;
    outputPath: string;
    serversPath: string;
    fromVersion: string;
    toVersion: string;
    removeWidgets: string[];
    debug: boolean;
    updateFiltersMdx: boolean;
    stack: boolean;
    onError: BehaviorOnError;
    treeColumnWidth?: string;
  }>(
    "$0",
    "Migrates a JSON export of a Content Server or an Atoti Jupyter notebook, saved with ActiveUI or Atoti version `--from-version` to be usable in version `--to-version`.",
    (args) => {
      args.option("input-path", {
        alias: "i",
        type: "string",
        demandOption: true,
        desc: "The path to the file to migrate. This file can be a JSON export of a Content Server, or an Atoti Jupyter notebook.",
      });
      args.option("output-path", {
        alias: "o",
        type: "string",
        demandOption: true,
        desc: "The path to the migrated file, ready to be imported into the Atoti Admin UI and used in your upgraded Atoti UI, if it is a Content Server export. Or ready to be used with your upgraded Atoti JupyterLab extension, if it is a notebook.",
      });
      args.option("servers-path", {
        alias: "s",
        type: "string",
        demandOption: true,
        desc: "The path to the JSON file holding the servers information.",
      });
      args.option("from-version", {
        alias: "f",
        type: "string",
        demandOption: true,
        choices: validFromVersions,
        desc: "The version to migrate from.",
      });
      args.option("to-version", {
        alias: "t",
        type: "string",
        demandOption: true,
        choices: validToVersions,
        desc: "The version to migrate to.",
      });
      args.option("remove-widgets", {
        type: "array",
        demandOption: false,
        desc: "A list of keys of widget plugins that should be removed during the migration.",
      });
      args.option("tree-column-width", {
        type: "string",
        alias: "tcw",
        demandOption: false,
        desc: `The variables (in px) with which to calculate the first column width of tree tables.
        Example: --tree-column-width 200,50 will result in 200px + (50 * maxLevelDepth).`,
      });
      args.option("update-filters-mdx", {
        type: "boolean",
        alias: "ufm",
        demandOption: false,
        desc: `Whether running the migration script updates the filters part of MDX queries to inline it with the style of MDX filters generated by Atoti UI.
        Defaults to true.
        Switching to false allows to avoid unexpected query updates during the migration.
        It is only supported if your target Atoti UI version if 5.0.x with x >= 29 or 5.1.y with y >= 9.`,
      });
      args.option("debug", {
        type: "boolean",
        demandOption: false,
        default: false,
        desc: "Whether an error report file is created at the end of the migration.",
      });
      args.option("stack", {
        type: "boolean",
        demandOption: false,
        default: false,
        desc: "Whether stacktraces are included in the error report file.",
      });
      args.option("on-error", {
        type: "string",
        demandOption: false,
        choices: [
          "keep-original",
          "keep-last-successful-version",
          "keep-going",
        ],
        default: "keep-original",
        desc: `The behavior when an error occurs during the migration of an item. This has an effect only when migrating through several versions in one go.
         
          For example, suppose that you're migrating from 5.0 to 5.3. For each saved item (e.g. a dashboard), three migration steps are applied: 5.0 => 5.1, 5.1 => 5.2, and 5.2 => 5.3. Each of these three steps might fail.
         
          More generically, assuming that the error occurred at step p out of a total of n, you can choose one of the following behaviors:
          \n- "keep-original": keep the original item untouched, as before the whole migration.
          \n- "keep-last-successful-version": keep the version of the item obtained after the first p-1 successful steps.
          \n- "keep-going": try to apply the n-p remaining steps to the version of the item obtained after step p, despite the error. Note that the remaining steps are likely to fail too, and in that case the result will be the same as "keep-last-succesful-version".
        `,
      });
      args.implies("stack", "debug");
    },
    async ({
      inputPath,
      outputPath,
      serversPath,
      fromVersion,
      toVersion,
      removeWidgets,
      treeColumnWidth,
      debug,
      updateFiltersMdx,
      stack,
      onError,
    }) => {
      const doesReportIncludeStacks = stack;
      const behaviorOnError = onError;

      const fileExtension = getFileExtension(inputPath);
      const { fromVersion: validFromVersion, toVersion: validToVersion } =
        convertVersions({
          fromVersion,
          toVersion,
        });

      const fileToMigrate: ContentRecord = await fs.readJSON(inputPath);

      const servers: {
        [serverKey: string]: {
          dataModel: DataModel<"raw">;
          url: string;
        };
      } & { contentServerVersion?: string } = await fs.readJSON(serversPath);

      if (fileExtension === "JSON") {
        const { counters, errorReport } = await migrateContentServer({
          contentServer: fileToMigrate,
          servers,
          fromVersion: validFromVersion,
          toVersion: validToVersion,
          keysOfWidgetPluginsToRemove: removeWidgets,
          doesReportIncludeStacks,
          behaviorOnError: onError,
          treeTableColumnWidth: treeColumnWidth
            ? getTreeColumnWidthFromArgs(treeColumnWidth)
            : undefined,
          shouldUpdateFiltersMdx:
            updateFiltersMdx === undefined ? true : updateFiltersMdx,
        });

        const { dir } = path.parse(outputPath);
        await Promise.all([
          fs.writeJSON(outputPath, fileToMigrate, { spaces: 2 }),
          logMigrationReport({
            counters,
            errorReport,
            debug,
            doesReportIncludeStacks,
            migrationOutputDirectory: dir,
            behaviorOnError,
          }),
        ]);
      } else {
        const { numberOfMigratedWidgets, numberOfFailures } =
          await migrateNotebook({
            notebook: fileToMigrate,
            servers,
            fromVersion: validFromVersion,
            toVersion: validToVersion,
          });

        await fs.writeJSON(outputPath, fileToMigrate, { spaces: 2 });
        console.log(
          `- Succesfully migrated ${numberOfMigratedWidgets} widget(s).`,
        );
        if (numberOfFailures > 0) {
          console.log(`- Failed to migrate ${numberOfFailures} widget(s)`);
        }
      }
    },
  )
  .check(({ fromVersion, toVersion }) => {
    if (convertFromVersion(fromVersion) >= convertToVersion(toVersion)) {
      throw new Error("--to-version must be greater than --from-version");
    }
    return true;
  })
  .demandCommand(1)
  .strict()
  .parse();
